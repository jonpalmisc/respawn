//
//  Copyright (c) 2022-2023 Jon Palmisciano. All rights reserved.
//
//  Use of this source code is governed by the BSD 3-Clause license; a full
//  copy of the license can be found in the LICENSE.txt file.
//

#pragma once

#include "respawn/chip.h"
#include "respawn/usb/client.h"

/// USB client responsible for "driving" the exploit process.
///
/// This is a superset of the standard USB client class, but with additional
/// primitives used in the exploit process and a full exploit implementation.
class ExploitDriver : public UsbClient {
  Chip m_chip;
  bool m_dump_payloads;

  /// Save a payload to the disk.
  static void dump_payload(std::vector<uint8_t> const &payload,
                           const std::string &name);

  bool do_no_leak();
  bool do_request_stall();
  bool do_request_leak();
  bool do_stall();

  bool send_bulk_data(std::vector<uint8_t> &data);

  bool run_reset_step();
  bool run_spray_step();
  bool run_setup_step();
  bool run_patch_step();

public:
  ExploitDriver(UsbClient const &client, Chip chip, bool dump_payloads = false);

  /// Run the entire exploit.
  ///
  /// It is assumed that the device is in a "clean DFU" state at this point in
  /// time, which is the responsibility of the caller to check.
  bool run();
};
